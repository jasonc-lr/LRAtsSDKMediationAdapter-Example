#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
#ifndef LRATSSDK_SWIFT_H
#define LRATSSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="LRAtsSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

@protocol LRAtsDelegate;
@class NSString;
enum LRStatus : NSInteger;
@class LRAtsConfiguration;
@class LRDealIdentifier;
@class LRDealIDsResult;
enum LRBloomFilterSyncStatus : NSInteger;
@protocol LRIdentifierData;
@class LREnvelope;

SWIFT_CLASS("_TtC8LRAtsSDK5LRAts")
@interface LRAts : NSObject
/// Shared instance used to interact with the SDK and its methods.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) LRAts * _Nonnull shared;)
+ (LRAts * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// <code>LRAtsDelegate</code> instance used to subscribe and to listen to SDK’s events and errors.
@property (nonatomic, weak) id <LRAtsDelegate> _Nullable delegate;
/// This property will be used for countries that are not found in any geo targeting legislation configured in the console.
/// If set to <code>true</code> ATS SDK will proceed, otherwise SDK will not generate any envelopes for those countries.
/// note:
/// Default value is <code>false</code>.
@property (nonatomic) BOOL hasConsentForNoLegislation;
/// Property used to control the status of the SDK.
/// When set to <code>true</code>, the SDK becomes disabled. As a result, the APIs will not function and API calls will not be possible. Setting the property to <code>false</code> changes the SDK status to <code>notInitialized</code> and re-initialization is required before API calls can be made again.
/// note:
/// Default value is <code>false</code>.
@property (nonatomic) BOOL isDisabled;
/// Property used for checking what is the current version of the SDK.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sdkVersion;)
+ (NSString * _Nonnull)sdkVersion SWIFT_WARN_UNUSED_RESULT;
/// Property used for checking what is the current status of the SDK.
@property (nonatomic, readonly) enum LRStatus status;
/// The purpose of this method is initialization of the SDK.
/// note:
/// This method needs to be called first in order to setup the SDK and use other methods.
/// \param sdkConfiguration <code>LRAtsConfiguration</code> object used for configuring SDK.
///
/// \param completion Completion handler of type <code>LRInitializeCompletion</code>.
///
- (void)initializeWith:(LRAtsConfiguration * _Nonnull)sdkConfiguration completion:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completion;
/// The purpose of this method is to retrieve a list of deal IDs for a given user identifier.
/// note:
/// To retrieve a valid Deal IDs, your ATS placement must be in an approved state. If the placement is unapproved, the SDK will return fake data which should only be used for testing. Information regarding the placement status can be found in the log output of the SDK.
/// \param userIdentifier <code>LRDealIdentifier</code> object representing the user for which the list of deal IDs is being retrieved.
///
/// \param completion Completion handler containing <code>LRDealIDsResult</code> which has optional array of <code>dealIDs</code> and <code>LRDealIDsResultStatus</code>.
///
- (void)getDealIDsFor:(LRDealIdentifier * _Nonnull)userIdentifier completion:(void (^ _Nonnull)(LRDealIDsResult * _Nonnull))completion;
/// This method synchronizes the bloom filters based on whether a configuration has changed and new bloom filters are available to download.
/// \param completion Completion handler that contains synchronization status of the bloom filters which can be <code>full</code>, <code>partial</code> or <code>error</code>.
///
- (void)syncFiltersWithCompletion:(void (^ _Nonnull)(enum LRBloomFilterSyncStatus))completion;
/// This method returns envelope for the specified identifier.
/// note:
/// To retrieve a valid envelope, your ATS placement must be in an approved state. If the placement is unapproved, the SDK will return fake data which should only be used for testing. Information regarding the placement status can be found in the log output of the SDK.
/// warning:
/// To retrieve envelopes, the bundle ID of your application (tied to your placement) must first be approved by a LiveRamp representative.
/// \param lrIdentifierData Object that conforms to <code>LRIdentifierData</code> protocol, this can be <code>LREmailIdentifier</code>, <code>LRPhoneNumberIdentifier</code>, <code>LRCustomIdentifier</code> or <code>LREnvelopeIdentifier</code> object.
///
///
/// returns:
/// <code>LREnvelope</code> object that contains <code>envelope</code>, <code>envelope24</code> and <code>envelope25</code> if successful or an <code>error</code> in case <code>envelope</code> couldn’t be generated.
- (void)getEnvelope:(id <LRIdentifierData> _Nonnull)lrIdentifierData completionHandler:(void (^ _Nonnull)(LREnvelope * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(ios,introduced=15);
/// This method returns envelope for the specified identifier.
/// note:
/// To retrieve a valid envelope, your ATS placement must be in an approved state. If the placement is unapproved, the SDK will return fake data which should only be used for testing. Information regarding the placement status can be found in the log output of the SDK.
/// warning:
/// To retrieve envelopes, the bundle ID of your application (tied to your placement) must first be approved by a LiveRamp representative.
/// \param lrIdentifierData Object that conforms to <code>LRIdentifierData</code> protocol, this can be <code>LREmailIdentifier</code>, <code>LRPhoneNumberIdentifier</code>, <code>LRCustomIdentifier</code> or <code>LREnvelopeIdentifier</code> object.
///
/// \param completion Completion containing <code>LREnvelope</code> object that contains <code>envelope</code>, <code>envelope24</code> and <code>envelope25</code> if successful or an <code>error</code> in case <code>envelope</code> couldn’t be generated.
///
- (void)getEnvelope:(id <LRIdentifierData> _Nonnull)lrIdentifierData completion:(void (^ _Nonnull)(LREnvelope * _Nullable, NSError * _Nullable))completion;
/// Calling this method will remove all data related to LRAtsSDK. To use the SDK after calling this method, you have to go through the initialization process again.
- (void)resetSDK;
@end


/// Class used to configure LRAts SDK during initialization.
/// warning:
/// Do not enable test mode in production environments as it may cause unintended behavior.
SWIFT_CLASS("_TtC8LRAtsSDK18LRAtsConfiguration")
@interface LRAtsConfiguration : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Create ATS configuration
/// \param configID Config ID obtained from LiveRamp Console. Required for ATS SDK.
///
- (nonnull instancetype)initWithConfigID:(NSString * _Nonnull)configID OBJC_DESIGNATED_INITIALIZER;
/// Create ATS configuration
/// \param configID Config ID obtained from LiveRamp Console. Required for ATS SDK.
///
/// \param apiKey Required for on-device ATS. To obtain it, generate an apiKey through App creation process on LiveRamp Console.
///
- (nonnull instancetype)initWithConfigID:(NSString * _Nonnull)configID apiKey:(NSString * _Nonnull)apiKey OBJC_DESIGNATED_INITIALIZER;
/// Create ATS configuration
/// note:
/// If <code>testMode</code> is enabled it’s not necessary to have valid <code>configID</code> to be able to call and test all SDK APIs
/// warning:
/// Do not enable test mode in production environments as it may cause unintended behavior.
/// \param configID Config ID obtained from LiveRamp Console. Required for ATS SDK.
///
/// \param apiKey Required for on-device ATS. To obtain it, generate an apiKey through App creation process on LiveRamp Console.
///
/// \param isTestMode If set to <code>true</code> test mode will be enabled in which test data is returned.
///
/// \param logToFileEnabled If set to <code>true</code> all log levels will be logged to file in /Documents/ats-sdk-ios/logs directory in the app sandbox.
///
- (nonnull instancetype)initWithConfigID:(NSString * _Nonnull)configID apiKey:(NSString * _Nonnull)apiKey isTestMode:(BOOL)isTestMode logToFileEnabled:(BOOL)logToFileEnabled OBJC_DESIGNATED_INITIALIZER;
/// Create ATS configuration
/// note:
/// If <code>testMode</code> is enabled it’s not necessary to have valid <code>appId</code> to be able to call and test all SDK APIs
/// warning:
/// Do not enable test mode in production environments as it may cause unintended behavior.
/// \param appId App Id obtained from LiveRamp Console. Required for ATS SDK.
///
/// \param apiKey Required for on-device ATS. To obtain it, generate an apiKey through App creation process on LiveRamp Console.
///
/// \param isTestMode If set to <code>true</code> test mode will be enabled in which test data is returned.
///
/// \param logToFileEnabled If set to <code>true</code> all log levels will be logged to file in /Documents/ats-sdk-ios/logs directory in the app sandbox.
///
- (nonnull instancetype)initWithAppId:(NSString * _Nonnull)appId apiKey:(NSString * _Nonnull)apiKey isTestMode:(BOOL)isTestMode logToFileEnabled:(BOOL)logToFileEnabled OBJC_DESIGNATED_INITIALIZER SWIFT_DEPRECATED_MSG("Use init(configID:apiKey:isTestMode:logToFileEnabled:) instead.", "initWithConfigID:apiKey:isTestMode:logToFileEnabled:");
@end


@interface LRAtsConfiguration (SWIFT_EXTENSION(LRAtsSDK))
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
@end

enum LREvent : NSInteger;

/// Protocol used for keeping track of SDK related events and errors. You can subscribe to notifications by implementing this protocol.
SWIFT_PROTOCOL("_TtP8LRAtsSDK13LRAtsDelegate_")
@protocol LRAtsDelegate
/// Method triggered in response to significant events within the SDK.
/// \param event An <code>LREvent</code> enum value representing the specific type of event that has occurred.
///
- (void)eventFiredWithEvent:(enum LREvent)event;
/// Method triggered when an error occurs inside the SDK.
/// \param error Contains info about the issue that the SDK is faced with.
///
- (void)didReceiveError:(NSError * _Nonnull)error;
@end

/// The synchronization status of the bloom filters.
typedef SWIFT_ENUM(NSInteger, LRBloomFilterSyncStatus, open) {
/// This status is returned when all the Bloom filters are fully downloaded.
  LRBloomFilterSyncStatusFull = 0,
/// This status is returned when the Bloom filters could only be partially downloaded.
  LRBloomFilterSyncStatusPartial = 1,
/// This status is returned if, for some reason, synchronization of the bloom filters has failed (sdkNotReady, noInternet, etc.).
  LRBloomFilterSyncStatusError = 2,
};


/// Used for categorizing different identifier types. Identifiers are used as an input of SDK’s methods for retrieving envelopes and dealIDs.
SWIFT_PROTOCOL("_TtP8LRAtsSDK16LRIdentifierData_")
@protocol LRIdentifierData
@optional
@property (nonatomic, readonly, copy) NSString * _Nonnull sha1;
@property (nonatomic, readonly, copy) NSString * _Nonnull sha256;
@property (nonatomic, readonly, copy) NSString * _Nonnull md5;
@property (nonatomic, readonly, copy) NSString * _Nonnull customID;
@property (nonatomic, readonly, copy) NSString * _Nonnull envelope;
@end


/// Custom identifier type used for <code>LRAts/getEnvelope(_:completion:)</code> method.
/// warning:
/// Due to the complexity of the customer ID mapping process, this class is only available for selected publishers who must go through an extensive onboarding process. Please note that you cannot use this API out-of-the-box.
SWIFT_CLASS("_TtC8LRAtsSDK18LRCustomIdentifier")
@interface LRCustomIdentifier : NSObject <LRIdentifierData>
/// String representation of custom identifier.
/// note:
/// Format of <code>customID</code> should be in format <code>ANA_ID:CUSTOM_ID</code>. <code>ANA_ID</code> represents the Account ID (provided by LiveRamp) whereas <code>CUSTOM_ID</code> represents the custom identifier.
@property (nonatomic, copy) NSString * _Nonnull customID;
/// Initializes a new <code>LRCustomIdentifier</code> instance with the provided custom identifier.
/// note:
/// Format of <code>customID</code> should be in format <code>ANA_ID:CUSTOM_ID</code>. <code>ANA_ID</code> represents the Account ID (provided by LiveRamp) whereas <code>CUSTOM_ID</code> represents the custom identifier.
/// warning:
/// Due to the complexity of the customer ID mapping process, this class is only available for selected publishers who must go through an extensive onboarding process. Please note that you cannot use this API out-of-the-box.
/// \param customID String representation of custom identifier.
///
- (nonnull instancetype)init:(NSString * _Nonnull)customID OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum LRDealIDsResultStatus : NSInteger;

/// Class used in response of <code>LRAts/getDealIDs(for:completion:)</code> method. Contains optional array of <code>dealIDs</code> and <code>LRDealIDsResultStatus</code>.
SWIFT_CLASS("_TtC8LRAtsSDK15LRDealIDsResult")
@interface LRDealIDsResult : NSObject
/// The current status of dealIDs.
@property (nonatomic) enum LRDealIDsResultStatus status;
/// List of dealIDs.
@property (nonatomic, copy) NSArray<NSString *> * _Nullable dealIDs;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The current status of dealIDs.
typedef SWIFT_ENUM(NSInteger, LRDealIDsResultStatus, open) {
/// This status is returned if filtering is fully done on all bloom filters.
  LRDealIDsResultStatusFull = 0,
/// This status is returned if filtering is only done partially with all the bloom filters. This can happen if at that moment all filters are not yet downloaded.
  LRDealIDsResultStatusPartial = 1,
/// This status is returned if there is no internet connection.
  LRDealIDsResultStatusOffline = 2,
/// This status is returned if the ATS SDK is not in a ready state when deal IDs are requested, or if no bloom filters are downloaded.
  LRDealIDsResultStatusError = 3,
};


/// Deal identifier type used for <code>LRAts/getDealIDs(for:completion:)</code> method.
SWIFT_CLASS("_TtC8LRAtsSDK16LRDealIdentifier")
@interface LRDealIdentifier : NSObject <LRIdentifierData>
/// Email value encrypted with SHA256.
@property (nonatomic, copy) NSString * _Nonnull sha256;
/// Initializes a new <code>LRDealIdentifier</code> instance with the provided email.
/// \param email String representation of the email value.
///
- (nonnull instancetype)initWithEmail:(NSString * _Nonnull)email OBJC_DESIGNATED_INITIALIZER;
/// Initializes a new <code>LRDealIdentifier</code> instance with the provided hash.
/// \param sha256 Email value encrypted with SHA256.
///
- (nonnull instancetype)initWithSha256:(NSString * _Nonnull)sha256 OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Email identifier type used for <code>LRAts/getEnvelope(_:completion:)</code> method.
SWIFT_CLASS("_TtC8LRAtsSDK17LREmailIdentifier")
@interface LREmailIdentifier : NSObject <LRIdentifierData>
/// Email value encrypted with SHA1.
@property (nonatomic, copy) NSString * _Nonnull sha1;
/// Email value encrypted with SHA256.
@property (nonatomic, copy) NSString * _Nonnull sha256;
/// Email value encrypted with MD5.
@property (nonatomic, copy) NSString * _Nonnull md5;
/// Initializes a new <code>LREmailIdentifier</code> instance with the provided email.
/// \param email String representation of the email value.
///
- (nonnull instancetype)init:(NSString * _Nonnull)email OBJC_DESIGNATED_INITIALIZER;
/// Initializes a new <code>LREmailIdentifier</code> instance with the provided hashes.
/// \param sha1 Email value encrypted with SHA1.
///
/// \param sha256 Email value encrypted with SHA256.
///
/// \param md5 Email value encrypted with MD5.
///
- (nonnull instancetype)initWithSha1:(NSString * _Nonnull)sha1 sha256:(NSString * _Nonnull)sha256 md5:(NSString * _Nonnull)md5 OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The envelope class represents an entity used for ad serving and tracking. Object of this class is returned from <code>LRAts/getEnvelope(_:completion:)</code>.
SWIFT_CLASS("_TtC8LRAtsSDK10LREnvelope")
@interface LREnvelope : NSObject
/// LiveRamp identity envelope for the specified identifier.
@property (nonatomic, copy) NSString * _Nullable envelope;
/// Meta-scoped envelope for the specified identifier (if Meta Conversion API Adapter is enabled).
@property (nonatomic, copy) NSString * _Nullable envelope24;
/// PAIR envelope for the specified identifier (if Google PAIR integration is enabled).
@property (nonatomic, copy) NSString * _Nullable envelope25;
/// ATS Direct envelope for the specified identifier (if ATS Direct integration is enabled).
@property (nonatomic, copy) NSString * _Nullable envelope26;
/// Google SSP envelope for the specified identifier (if Google SSP integration is enabled).
@property (nonatomic, copy) NSString * _Nullable envelope27;
/// Base64 decoded segments from envelope25.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable pairSegments;
/// Base64 decoded segments from envelope26.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable atsDirectSegments;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Envelope identifier type used for <code>LRAts/getEnvelope(_:completion:)</code> method.
SWIFT_CLASS("_TtC8LRAtsSDK20LREnvelopeIdentifier")
@interface LREnvelopeIdentifier : NSObject <LRIdentifierData>
/// String representation of the envelope value.
@property (nonatomic, copy) NSString * _Nonnull envelope;
/// Initializes a new <code>LREnvelopeIdentifier</code> instance with the provided envelope.
/// \param envelope String representation of the envelope value.
///
- (nonnull instancetype)init:(NSString * _Nonnull)envelope OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Reflects the error that occurred in the SDK.
typedef SWIFT_ENUM(NSInteger, LRError, open) {
/// Dispatched when functionality is not yet implemented.
  LRErrorNotImplemented = 0,
/// Dispatched when the configID is missing.
  LRErrorMissingConfigID = 1,
/// Dispatched when fetching the configuration failed.
  LRErrorFetchingConfigurationFailed = 2,
/// Dispatched when the configuration is invalid.
  LRErrorInvalidConfiguration = 3,
/// Dispatched when fetching envelope failed.
  LRErrorFetchingEnvelopeFailed = 4,
/// Dispatched when refreshing envelope failed.
  LRErrorRefreshingEnvelopeFailed = 5,
/// Dispatched when no consent was given.
  LRErrorNoConsent = 6,
/// Dispatched when ATS is disabled in the country.
  LRErrorAtsDisabledInCountry = 7,
/// Dispatched when the SDK is disabled.
  LRErrorSdkIsDisabled = 8,
/// Dispatched when the SDK is not ready.
  LRErrorSdkIsNotReady = 9,
/// Dispatched when there is no internet connection.
  LRErrorNoInternet = 10,
/// Dispatched when the SDK is already loading.
  LRErrorSdkIsAlreadyLoading = 11,
/// Dispatched when the SDK is already initialized.
  LRErrorSdkIsAlreadyInitialized = 12,
/// Dispatched when the SDK initialization was cancelled.
  LRErrorSdkInitializationCancelled = 13,
/// Dispatched when database failure occurs.
  LRErrorDatabaseFailure = 14,
};
static NSString * _Nonnull const LRErrorDomain = @"LRAtsSDK.LRError";

/// Reflects the event that occurred in the SDK.
typedef SWIFT_ENUM(NSInteger, LREvent, open) {
/// Dispatched when SDK initialization process starts.
  LREventLoading = 0,
/// Dispatched when SDK is fully initialized.
  LREventReady = 1,
/// Dispatched when SDK reset is complete.
  LREventReset = 2,
/// Dispatched when the automatic sync is disabled and bloom filters need to be synchronized with the backend .
  LREventShouldSynchronize = 3,
/// Dispatched when SDK is disabled.
  LREventDisabled = 4,
/// Dispatched when bloom filters synchronization is fully completed.
  LREventSyncFull = 5,
/// Dispatched when bloom filters synchronization is partially completed.
  LREventSyncPartial = 6,
/// Dispatched when an error has occurred during the bloom filters synchronization.
  LREventSyncError = 7,
};



/// Phone number identifier type used for <code>LRAts/getEnvelope(_:completion:)</code> method.
SWIFT_CLASS("_TtC8LRAtsSDK23LRPhoneNumberIdentifier")
@interface LRPhoneNumberIdentifier : NSObject <LRIdentifierData>
/// Phone number value encrypted with SHA1.
@property (nonatomic, copy) NSString * _Nonnull sha1;
/// Initializes a new <code>LRPhoneNumberIdentifier</code> instance with the provided phone number.
/// \param phoneNumber String representation of the phone number value.
///
- (nonnull instancetype)init:(NSString * _Nonnull)phoneNumber OBJC_DESIGNATED_INITIALIZER;
/// Initializes a new <code>LRPhoneNumberIdentifier</code> instance with the provided hash.
/// \param sha1 Phone number value encrypted with SHA1.
///
- (nonnull instancetype)initWithSha1:(NSString * _Nonnull)sha1 OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Reflects the current status of the SDK.
typedef SWIFT_ENUM(NSInteger, LRStatus, open) {
/// The process of initialization hasn’t started.
  LRStatusNotInitialized = 0,
/// The SDK is currently in the process of initialization.
  LRStatusLoading = 1,
/// The SDK is initialized and ready to be used.
  LRStatusReady = 2,
/// The SDK encountered an error and needs to be reset.
  LRStatusError = 3,
/// The SDK cannot be initialized.
  LRStatusDisabled = 4,
};












#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
